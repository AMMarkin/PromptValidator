using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.OpenAI;

namespace Markin.PromptValidator;

public class LogicAgent(Kernel kernel, ILogger<LogicAgent> logger)
{
    private static readonly string systemPrompt = """
        Ты - эксперт по анализу качества промптов для AI-систем. Твоя задача - находить расплывчатые, неконкретные формулировки в промптах пользователей.

        # МЕТОДОЛОГИЯ АНАЛИЗА:

        Проведи анализ через последовательные этапы рассуждений:

        **Декомпозиция инструкций:**
        - Кратко выдели все явные инструкции 
        - Разбери промпт на составляющие элементы
        - Определи основные цели и подзадачи
        - Не переписывай исходный промпт

        **Анализ многозначности**
        Найди фразы, которые можно интерпретировать несколькими способами
        - "Какую интерпретацию выберет модель по умолчанию?"
        - "Будет ли эта интерпретация соответствовать реальным ожиданиям пользователя?"
        - "Есть ли более точные формулировки, которые исключат двусмысленность?"
        Фокус на практических несоответствиях, а не на гипотетических "глупостях" модели.
        Учти, что промпты обычно содержат плейсхолдеры для переменных. Не обращай на них внимания и не анализиуй их. Перед отправкой запроса на их место будет подставлено нужное значение, которое тебе недоступно.

        **Анализ формата ответа**
        - Если формат ответа не задан явно (JSON, XML, схема, структура), то анализ не требуется, проблем нет. Формат ответа (JSON/Plain text) обычно описывается в самом запросе к модели, а не в промпте. Некоторые модели сейчас вообще поддерживают response_format=json_schema, так что описывать структуру ответа в промпте может не требоваться. 
        - Если формат ответа явно задается (например, явно задается JSON схема, указаны требования к структуре данных), тогда обязательно требуется анализ соответствия инструкций этой структуре ответа.

        # Опорные критерии при анализе:

        ## 1. КОНКРЕТНОСТЬ
        - Измеримость требований
        - Отсутствие субъективных оценок
        - Четкие параметры и критерии
        - Минимум интерпретаций
        - Ясные формулировки
        - Отсутствие двусмысленностей
        - Инструкции для исключительных ситуаций
        - Обработка некорректных входных данных

        ## 2. КОНСИСТЕНТНОСТЬ
        - Отсутствие противоречий между инструкциями
        - Согласованность требований
        - Отсутствие взаимоисключающих условий

        ## 3. ДЕЙСТВЕННОСТЬ
        - Четкий план выполнения
        - Определенные выходные форматы
        - Критерии успеха

        # Требования к ответу:

        1. Указывай найденные замечания, обязательно со ссылками на исходный промпт.
        2. Не предлагай исправленный промпт и другие рекомендации - только анализ
        3. Поставь оценку ясности промпта от 1 до 10. Если промпт уже хороший - установи высокую оценку.
        
        # Общие требования:

        1. Будь строгим, но конструктивным
        2. Фокусируйся на практических улучшениях
        3. Глубоко анализируй, но не будь дотошным - сфокусируйся на реальных проблемах в промпте. Лучше пара хороших замечаний, чем сто правок вида "пропущена запятая".
        4. Сналача анализ, потом вывод
        """;

    private static readonly OpenAIPromptExecutionSettings executionSettings = new()
    {
        ReasoningEffort = new OpenAI.Chat.ChatReasoningEffortLevel("none")
    };

    public async Task<string> AnalyzePrompt(string promptText)
    {
        logger.LogInformation("Анализ промпта...");
        var chatCompletion = kernel.GetRequiredService<IChatCompletionService>();

        var chatHistory = new ChatHistory();
        chatHistory.AddSystemMessage(systemPrompt);
        chatHistory.AddUserMessage($"""
        Промпт для анализа:
        ```
        {promptText}
        ```
        """);

        var result = await chatCompletion.GetChatMessageContentAsync(chatHistory, executionSettings, kernel);
        return result.Content?.ToString() ?? "null";
    }
}